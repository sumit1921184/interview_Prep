# React Core Mechanics & Hooks 

---

## 1. How React Works Internally (High Level)

Whenever state or props change in React, the update goes through **two main phases**:

### âž¤ Render Phase (Thinking Phase)

What happens here:

* React calls your component function again
* Creates a new Virtual DOM
* Compares old Virtual DOM with new one (diffing)
* Figures out what changed (reconciliation)

Important:

âœ… No real DOM updates here
âœ… Must be pure (no side effects)

---

### âž¤ Commit Phase (Applying Phase)

What happens here:

* React updates the real DOM
* Browser paints changes
* `useEffect` runs
* cleanup functions run

This is where the UI actually changes.

---

## 2. Why React Renders Multiple Times

React re-renders when:

* State changes
* Props change
* Parent re-renders
* Context value changes

Rendering is cheap. DOM updates are expensive â€” thatâ€™s why React uses Virtual DOM.

---

## 3. What is Batching?

Batching does NOT only mean batching the same state variable.

ðŸ‘‰ React batches ALL state updates (same or different states, even across components) that happen in the same event loop tick into a single render and commit.

This is a performance optimization to avoid unnecessary re-renders.

### Important clarification:

âŒ Batching is not limited to one state variable
âœ… It groups multiple state updates that occur together

Batching = React groups multiple state updates into ONE render + ONE commit.

### Example (batched):

```js
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

Result:

* count increases by 2
* only one render happens

---

### Wrong way (stale state problem):

```js
setCount(count + 1);
setCount(count + 1);
```

Result:

* increases by 1 (not 2)

Reason: both use old state snapshot

---

## 4. Stale State (Very Common React Bug)

Stale state happens when React uses an OLD snapshot of state instead of the latest value during updates.

This usually occurs when you update state using the current variable instead of the functional updater.

### âŒ Stale state example:

```js
setCount(count + 1);
setCount(count + 1);
```

React reads `count` only once and both updates use the same old value.

Result:

* Expected: +2
* Actual: +1 âŒ

---

### âŒ Another stale state example:

```js
setScore(score + 5);
setScore(score + 5);
```

Result becomes +5 instead of +10

---

### âœ… Correct way (always safe):

```js
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

```js
setScore(prev => prev + 5);
setScore(prev => prev + 5);
```

Now React always uses the latest state value.

---

### ðŸŽ¯ Interview takeaway:

Stale state happens due to closures capturing old values. Functional updates prevent this issue and work correctly with batching.

---

## 5. When Batching Does NOT Happen

### A) Forced sync updates

```js
flushSync(() => setCount(c => c + 1));
flushSync(() => setCount(c => c + 1));
```

Each causes separate render

---

### B) Older React async code (before React 18)

```js
setTimeout(() => {
  setCount(c => c + 1);
  setCount(c => c + 1);
}, 1000);
```

Old React â†’ renders twice

React 18+ â†’ batched automatically

---

## 5. Why Infinite Re-render Happens

Wrong (inside component body):

```js
setCount(count + 1);
```

This runs during render â†’ infinite loop

---

Correct places for setState:

* Event handlers
* useEffect
* async callbacks

---

## 6. useEffect Timing

useEffect runs in:

âœ… Commit phase

Used for:

* API calls
* subscriptions
* DOM manipulation
* timers

Cleanup runs before next effect or unmount.

---

## 7. Strict Mode (React dev behavior)

In development React intentionally:

* renders components twice
* runs effects twice

Purpose:

* detect side effects
* catch unsafe logic

Production does NOT double render.

---

## 8. Correct State Update Pattern (Senior level rule)

Always use functional update when new state depends on old state:

```js
setCount(prev => prev + 1);
```

Prevents:

* stale closures
* batching bugs
* race conditions

---

# Common Bugs & Fixes

| Bug              | Cause              | Fix                        |
| ---------------- | ------------------ | -------------------------- |
| Infinite render  | setState in render | move to useEffect or event |
| Wrong value      | stale state        | use functional update      |
| Multiple renders | forced sync        | allow batching             |

---

# Interview Summary Points (VERY IMPORTANT)

â€¢ React has Render Phase (calculation) and Commit Phase (DOM updates)
â€¢ Virtual DOM is compared using diffing & reconciliation
â€¢ useEffect runs after DOM commit
â€¢ React batches multiple state updates into one render
â€¢ Functional state updates are safest
â€¢ Batching can be broken by flushSync or old async contexts
â€¢ Infinite renders happen when state updates run during render
â€¢ Strict Mode double-renders only in development

---

# Perfect One-Line Interview Explanation

"React calculates UI changes in the render phase using Virtual DOM diffing, batches state updates for performance, and applies real DOM updates in the commit phase where effects run."

---

End of revision notes.
